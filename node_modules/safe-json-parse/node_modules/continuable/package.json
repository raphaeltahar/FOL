{
  "name": "continuable",
  "version": "1.1.3",
  "description": "Idea for callbacks as values",
  "keywords": [],
  "author": {
    "name": "Raynos",
    "email": "raynos2@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Raynos/continuable.git"
  },
  "main": "index",
  "homepage": "https://github.com/Raynos/continuable",
  "contributors": [
    {
      "name": "Raynos"
    }
  ],
  "bugs": {
    "url": "https://github.com/Raynos/continuable/issues",
    "email": "raynos2@gmail.com"
  },
  "dependencies": {},
  "devDependencies": {
    "tape": "~1.0.2"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/Raynos/continuable/raw/master/LICENSE"
    }
  ],
  "scripts": {
    "test": "node ./test/index.js"
  },
  "testling": {
    "files": "test/index.js",
    "browsers": [
      "ie/8..latest",
      "firefox/16..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest"
    ]
  },
  "readme": "# continuable\n\n[![build status][1]][2] [![dependency status][3]][4]\n\n[![browser support][5]][6]\n\nIdea for callbacks as values\n\n## Example\n\n```js\nvar readFile = function (uri) {\n    return function (cb) {\n        fs.readFile(uri, cb)\n    }\n}\n\nfunction map(source, lambda) {\n    return function continuable(callback) {\n        source(function (err, value) {\n            callback(err, err ? null : lambda(value))\n        })\n    }\n}\n\nvar asString = map(readFile(\"/tmp/foo.json\"), String)\nvar asJSON = map(asString, function (x) { return JSON.parse(x) })\n\nasJSON(function (err, value) {\n    /* do stuff with JSON */\n})\n```\n\n## Docs\n\n### `Continuable(callback)`\n\n```js\ntype Continuable := (callback:(Error, Value) => void) => void\n```\n\nA continuable is simply a function that takes a single argument, a callback.\nThe callback get's called with the normal node error and value pattern.\n\n```js\n// readFile := (String) => Continuable<Buffer>\nvar readFile = function (uri) {\n    return function continuable(callback) {\n        fs.readFile(uri, callback)\n    }\n}\n```\n\nThe reason to have a continuable instead of passing a callback directly into\nanother value is that a continuable is a concrete value that can be returned.\n\nWhich means you can call useful functions on this value like `map` and `join`\n\n### `map(source, lambda)`\n\n```js\nmap := (source:Continuable<A>, lambda:(A) => B) => Continuable<B>\n```\n\nmap takes a transformation function and a continuable and returns a new\ncontinuable. The new continuable is the value of the first continuable\ntransformed by your mapping function.\n\n```js\nvar asString = map(readFile(\"/tmp/foo.json\"), String)\nvar asJSON = map(asString, function (x) { return JSON.parse(x) })\n\nasJSON(function (err, json) {\n    /* do stuff */\n})\n```\n\n### `join(continuable)`\n\n```js\njoin := (source:Continuable<Continuable<T>>) => Continuable<T>\n```\n\n`join` takes a continuable that contains another continuable and flattens it by\none layer. This is useful if you return another asynchronous operation from\n`map`\n\n```js\nvar asString = map(readFile(\"/tmp/foo.json\"), String)\nvar asJSON = map(asString, function (x) { return JSON.parse(x) })\n\nvar write = map(asJSON, function (json) {\n    return function continuable(cb) {\n        fs.writeFile(\"/tmp/bar.json\", JSON.stringify(json), cb)\n    }\n})\n\njoin(write)(function (err, writeResult) {\n    /* stuff */\n})\n```\n\n### `of(value)`\n\n```js\nof := (Value) => Continuable<Value>\n```\n\n`of` takes any value and returns a Continuable for this value. This is useful\n    if you want to implement a function that either returns a value or a\n    continuable.\n\n```js\nfunction getThing() {\n    var thing = localStorage.getItem(\"thing\")\n\n    if (thing) return of(thing)\n\n    return ajax(\"/thing\")\n}\n```\n\n### `error(err)`\n\n```js\nerror := (Error) => Continuable<void>\n```\n\n`error` takes any error and returns a Continuable that will return said error.\n    This is useful if you want to transform a normal continuable into an\n    error state one.\n\n```js\nvar body = getBody(req, res)\n\nvar dbWrite = map(body, function (body) {\n    if (!body) {\n        return error(new Error(\"Need body\"))\n    }\n\n    return db.write(body)\n})\n\njoin(dbWrite)(function (err, writeResult) {\n    /* do stuff */\n})\n```\n\n### `chain(continuable, lambda)`\n\n```js\nchain := (Continuable<A>, (A) => Continuable<B>) => Continuable<B>\n```\n\n`chain` takes a lambda function that is given the value and returns another\n    continuables. The result will be a continuable given the value of the\n    returned continuable.\n\nIn combination with `of` this makes `Continuable` a monad.\n\nAlternatively this can be seen as sugar for `map` followed by `join`\n\n```js\nvar body = getBody(req, res)\n\nvar dbWrite = chain(body, function (body) {\n    if (!body) {\n        return error(new Error(\"Need body\"))\n    }\n\n    return db.write(body)\n})\n\ndbWrite(function (err, writeResult) {\n    /* do stuff */\n})\n```\n\n### `either(continuable, left, right?)`\n\n```js\neither := (source: Continuable<A>,\n           left: (Error) => Continuable<B>,\n          right?: (A) => Continuable<B>)\n    => Continuable<B>\n```\n\n`either` takes a source continuable and a left and right function.\n    It will either call the left function with the error in source\n    or call the right function with the value in the source.\n\nThe returned continuable will contain the value returned from\n    either left or right. Note that left and right return\n    continuables themself.\n\n```js\nvar fs = require(\"fs\")\nvar either = require(\"continuable/either\")\n\nvar fileStat = fs.stat.bind(null, \"./package.json\")\nvar fileExists = either(fileStat, function left(err) {\n    return fs.writeFile.bind(null, \"./package.json\", \"{}\")\n}) // note the right function is optional\n\nvar file = chain(fileExists, function () {\n    return fs.readFile.bind(null, \"./package.json\")\n})\n\nfile(function (err, body) {\n    // There is no error because we create an empty file if the\n    // stat failed. Body is either body or {}\n})\n```\n\n## Installation\n\n`npm install continuable`\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/continuable.png\n  [2]: https://travis-ci.org/Raynos/continuable\n  [3]: https://david-dm.org/Raynos/continuable.png\n  [4]: https://david-dm.org/Raynos/continuable\n  [5]: https://ci.testling.com/Raynos/continuable.png\n  [6]: https://ci.testling.com/Raynos/continuable\n",
  "readmeFilename": "README.md",
  "_id": "continuable@1.1.3",
  "dist": {
    "shasum": "d50ac90e87ffd47299e24b4e4c96d83b9700f4ea"
  },
  "_from": "continuable@~1.1.3",
  "_resolved": "https://registry.npmjs.org/continuable/-/continuable-1.1.3.tgz"
}
